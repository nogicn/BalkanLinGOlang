// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package worddbc

import (
	"context"
	"database/sql"
)

const createWord = `-- name: CreateWord :exec
INSERT INTO word (foreignWord, foreignDescription, nativeWord, nativeDescription, pronunciation, dictionary_id) 
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
`

type CreateWordParams struct {
	ForeignWord        string
	ForeignDescription string
	NativeWord         string
	NativeDescription  string
	Pronunciation      string
	DictionaryId       int64
}

func (q *Queries) CreateWord(ctx context.Context, arg CreateWordParams) error {
	_, err := q.db.ExecContext(ctx, createWord,
		arg.ForeignWord,
		arg.ForeignDescription,
		arg.NativeWord,
		arg.NativeDescription,
		arg.Pronunciation,
		arg.DictionaryId,
	)
	return err
}

const deleteWordByDictionaryID = `-- name: DeleteWordByDictionaryID :exec
DELETE FROM word WHERE dictionary_id = ?1
`

func (q *Queries) DeleteWordByDictionaryID(ctx context.Context, dictionaryid int64) error {
	_, err := q.db.ExecContext(ctx, deleteWordByDictionaryID, dictionaryid)
	return err
}

const deleteWordByID = `-- name: DeleteWordByID :exec
DELETE FROM word WHERE id = ?1
`

func (q *Queries) DeleteWordByID(ctx context.Context, wordid int64) error {
	_, err := q.db.ExecContext(ctx, deleteWordByID, wordid)
	return err
}

const deleteWordByMeaning = `-- name: DeleteWordByMeaning :exec
DELETE FROM word 
WHERE foreignWord = ?1 AND foreignDescription = ?2 AND nativeWord = ?3 AND nativeDescription = ?4
`

type DeleteWordByMeaningParams struct {
	ForeignWord        string
	ForeignDescription string
	NativeWord         string
	NativeDescription  string
}

func (q *Queries) DeleteWordByMeaning(ctx context.Context, arg DeleteWordByMeaningParams) error {
	_, err := q.db.ExecContext(ctx, deleteWordByMeaning,
		arg.ForeignWord,
		arg.ForeignDescription,
		arg.NativeWord,
		arg.NativeDescription,
	)
	return err
}

const getAllWords = `-- name: GetAllWords :many
SELECT id, foreignword, foreigndescription, nativeword, nativedescription, pronunciation, dictionary_id FROM word
`

func (q *Queries) GetAllWords(ctx context.Context) ([]Word, error) {
	rows, err := q.db.QueryContext(ctx, getAllWords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Word
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.Foreignword,
			&i.Foreigndescription,
			&i.Nativeword,
			&i.Nativedescription,
			&i.Pronunciation,
			&i.DictionaryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWordsNotInUserWord = `-- name: GetAllWordsNotInUserWord :many
SELECT id, foreignword, foreigndescription, nativeword, nativedescription, pronunciation, dictionary_id FROM word 
WHERE id NOT IN (SELECT word_id as id FROM user_word WHERE user_id = ?1)
`

func (q *Queries) GetAllWordsNotInUserWord(ctx context.Context, userid int64) ([]Word, error) {
	rows, err := q.db.QueryContext(ctx, getAllWordsNotInUserWord, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Word
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.Foreignword,
			&i.Foreigndescription,
			&i.Nativeword,
			&i.Nativedescription,
			&i.Pronunciation,
			&i.DictionaryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordByDictionaryID = `-- name: GetWordByDictionaryID :many
SELECT id, foreignword, foreigndescription, nativeword, nativedescription, pronunciation, dictionary_id FROM word WHERE dictionary_id = ?1
`

func (q *Queries) GetWordByDictionaryID(ctx context.Context, dictionaryid int64) ([]Word, error) {
	rows, err := q.db.QueryContext(ctx, getWordByDictionaryID, dictionaryid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Word
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.Foreignword,
			&i.Foreigndescription,
			&i.Nativeword,
			&i.Nativedescription,
			&i.Pronunciation,
			&i.DictionaryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordByID = `-- name: GetWordByID :one
SELECT id, foreignword, foreigndescription, nativeword, nativedescription, pronunciation, dictionary_id FROM word WHERE id = ?1
`

func (q *Queries) GetWordByID(ctx context.Context, wordid int64) (Word, error) {
	row := q.db.QueryRowContext(ctx, getWordByID, wordid)
	var i Word
	err := row.Scan(
		&i.ID,
		&i.Foreignword,
		&i.Foreigndescription,
		&i.Nativeword,
		&i.Nativedescription,
		&i.Pronunciation,
		&i.DictionaryID,
	)
	return i, err
}

const searchWordByDictionaryID = `-- name: SearchWordByDictionaryID :many
SELECT id, foreignword, foreigndescription, nativeword, nativedescription, pronunciation, dictionary_id FROM word 
WHERE dictionary_id = ?1 AND (foreignWord LIKE '%' || ?2 || '%' OR nativeWord LIKE '%' || ?2 || '%')
`

type SearchWordByDictionaryIDParams struct {
	DictionaryId int64
	Word         sql.NullString
}

func (q *Queries) SearchWordByDictionaryID(ctx context.Context, arg SearchWordByDictionaryIDParams) ([]Word, error) {
	rows, err := q.db.QueryContext(ctx, searchWordByDictionaryID, arg.DictionaryId, arg.Word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Word
	for rows.Next() {
		var i Word
		if err := rows.Scan(
			&i.ID,
			&i.Foreignword,
			&i.Foreigndescription,
			&i.Nativeword,
			&i.Nativedescription,
			&i.Pronunciation,
			&i.DictionaryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWord = `-- name: UpdateWord :exec
UPDATE word 
SET foreignWord = ?1, foreignDescription = ?2, nativeWord = ?3, nativeDescription = ?4, pronunciation = ?5 
WHERE id = ?6
`

type UpdateWordParams struct {
	ForeignWord        string
	ForeignDescription string
	NativeWord         string
	NativeDescription  string
	Pronunciation      string
	WordId             int64
}

func (q *Queries) UpdateWord(ctx context.Context, arg UpdateWordParams) error {
	_, err := q.db.ExecContext(ctx, updateWord,
		arg.ForeignWord,
		arg.ForeignDescription,
		arg.NativeWord,
		arg.NativeDescription,
		arg.Pronunciation,
		arg.WordId,
	)
	return err
}
